/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/tiny-emitter/index.js
var require_tiny_emitter = __commonJS({
  "node_modules/tiny-emitter/index.js"(exports, module2) {
    function E() {
    }
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name, callback, ctx) {
        var self = this;
        function listener() {
          self.off(name, listener);
          callback.apply(ctx, arguments);
        }
        ;
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    module2.exports = E;
    module2.exports.TinyEmitter = E;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TWPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block3, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block3(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance7, create_fragment7, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment7 ? create_fragment7($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/task-handler.ts
var import_child_process = require("child_process");
var import_util = require("util");

// node_modules/neverthrow/dist/index.es.js
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var ResultAsync = class {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise) {
    const newPromise = promise.then((value) => new Ok(value));
    return new ResultAsync(newPromise);
  }
  static fromPromise(promise, errorFn) {
    const newPromise = promise.then((value) => new Ok(value)).catch((e) => new Err(errorFn(e)));
    return new ResultAsync(newPromise);
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f) {
    return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f(res.value));
    })));
  }
  mapErr(f) {
    return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return new ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f(res.value);
      return newValue instanceof ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t) {
    return this._promise.then((res) => res.unwrapOr(t));
  }
  /**
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
};
var errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var appendValueToEndOfList = (value) => (list) => [...list, value];
var combineResultList = (resultList) => resultList.reduce((acc, result) => acc.isOk() ? result.isErr() ? err(result.error) : acc.map(appendValueToEndOfList(result.value)) : acc, ok([]));
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => resultList.reduce((acc, result) => result.isErr() ? acc.isErr() ? err([...acc.error, result.error]) : err([result.error]) : acc.isErr() ? acc : ok([...acc.value, result.value]), ok([]));
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args) => {
      try {
        const result = fn(...args);
        return ok(result);
      } catch (e) {
        return err(errorFn ? errorFn(e) : e);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
var ok = (value) => new Ok(value);
var err = (err2) => new Err(err2);
var Ok = class {
  constructor(value) {
    this.value = value;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f) {
    return ok(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return f(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f) {
    return f(this.value);
  }
  asyncMap(f) {
    return ResultAsync.fromSafePromise(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value = this.value;
    return function* () {
      return value;
    }();
  }
  _unsafeUnwrap(_) {
    return this.value;
  }
  _unsafeUnwrapErr(config) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config);
  }
};
var Err = class {
  constructor(error) {
    this.error = error;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f) {
    return err(f(this.error));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return f(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v) {
    return v;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error = this.error;
    return function* () {
      yield err(error);
      throw new Error("Do not use this generator out of `safeTry`");
    }();
  }
  _unsafeUnwrap(config) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config);
  }
  _unsafeUnwrapErr(_) {
    return this.error;
  }
};
var fromThrowable = Result.fromThrowable;

// src/task-handler.ts
var import_obsidian = require("obsidian");
var asyncExec = (0, import_util.promisify)(import_child_process.exec);
var TaskHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.reportColumnCache = /* @__PURE__ */ new Map();
    this.execTW = (args) => {
      let command = this.plugin.settings.tw_bin;
      if (Array.isArray(args))
        command += " " + args.map((s) => `"${s}"`).join(" ");
      else
        command += " " + args;
      this.plugin.logger.debug_log("Executing: \n", command);
      return ResultAsync.fromPromise(asyncExec(command).then((v) => v.stdout).then((r) => {
        this.plugin.logger.debug_log("Result: \n", r);
        return r;
      }), (e) => e instanceof Error ? e : new Error(String(e)));
    };
    this.fetchReportColumns = async (clean_report) => {
      if (this.plugin.settings.cache_columns && this.reportColumnCache.has(clean_report)) {
        return ok(this.reportColumnCache.get(clean_report));
      }
      const label_commands = ["_get", `rc.report.${clean_report}.labels`];
      const column_commands = ["_get", `rc.report.${clean_report}.columns`];
      const [labels, columns] = await Promise.all(
        [
          this.execTW(label_commands).then((r) => r.map((s) => s.trim().split(","))),
          this.execTW(column_commands).then((r) => r.map((s) => s.trim().split(",")))
        ]
      );
      if (labels.isErr() || columns.isErr()) {
        return errAsync(new Error("Error trying to get columns/labels for report"));
      }
      const cols = columns.value.filter((p) => p.trim() !== "").map((col, i) => ({ label: labels.value[i], type: col }));
      if (this.plugin.settings.cache_columns) {
        this.reportColumnCache.set(clean_report, cols);
      }
      return ok(cols);
    };
    this.fetchReportTasks = async (clean_report, clean_command) => {
      const cleanReportNoQuotes = clean_report.slice(1, clean_report.length - 1);
      const colRes = await this.fetchReportColumns(cleanReportNoQuotes);
      if (colRes.isErr()) {
        return err(colRes.error);
      }
      const col = colRes.value;
      if (col.length === 0)
        return ok({ columns: [], tasks: [], printedColumns: [] });
      const colOverride = `rc.report.${cleanReportNoQuotes}.columns:${["uuid.long", "status.short", ...col.map((c) => c.type)].join(",")}`;
      const labOverride = `rc.report.${cleanReportNoQuotes}.labels:${["_tw_uuid", "_tw_status", ...col.map((c) => c.label)].join(",")}`;
      const verbosityOverride = `rc.verbose:label`;
      const colorOverride = `rc.color:0`;
      const widthOverride = `rc.defaultwidth:0`;
      const heightOverride = `rc.defaultheight:0`;
      const rowPaddingOverride = `rc.row.padding:0`;
      const columnPaddingOverride = `rc.column.padding:1`;
      const hyphenateOverride = `rc.hyphenate:0`;
      const fullcommand = `${clean_report} ${clean_command ? clean_command + " " : ""}` + [colOverride, labOverride, verbosityOverride, colorOverride, widthOverride, heightOverride, rowPaddingOverride, columnPaddingOverride, hyphenateOverride].map((s) => `"${s}"`).join(" ");
      const twRes = await this.execTW(fullcommand);
      if (twRes.isErr()) {
        return ok({ columns: col, tasks: [], printedColumns: [] });
      }
      const tw = twRes.value;
      const [labels, headerLine, ...taskLines] = tw.split("\n");
      const ocurrences = linearSearchOcurrence(" ", headerLine);
      const separatedLabels = sliceUsingSeparatorIndexes(labels, ocurrences).slice(2).map((l) => l.trim());
      const printedColumns = separatedLabels.map((l) => ({
        label: l,
        type: col.find((c) => c.label === l).type
      }));
      const taskList = [];
      for (let i = 0; i < taskLines.length; i++) {
        const taskLine = taskLines[i];
        const [rawUuid, rawStatus, ...rawData] = sliceUsingSeparatorIndexes(taskLine, ocurrences);
        const uuid = rawUuid.trim();
        if (uuid === "") {
          const prevTask = taskList[taskList.length - 1];
          rawData.forEach((v, i2, rawData2) => {
            const indData = rawData2[i2].trim();
            if (indData === "")
              return;
            prevTask.data[i2] += `
	${indData}`;
          });
          continue;
        }
        taskList.push({
          uuid,
          status: rawStatus.trim(),
          data: rawData.map((d) => d.trim())
        });
      }
      return ok({
        tasks: taskList,
        columns: col,
        printedColumns
      });
    };
    this.setTaskStatus = async (uuid, status) => {
      return this.execTW([uuid, "modify", `status:${status}`]).map((t) => {
      });
    };
  }
  clearColumnCache() {
    const cleared = this.reportColumnCache.size;
    this.reportColumnCache.clear();
    return cleared;
  }
  async getTasks(clean_report, clean_command) {
    const timestamp = Date.now();
    const result = await this.fetchReportTasks(clean_report, clean_command);
    if (result.isErr()) {
      this.plugin.logger.error_log(result.error);
      throw err(result.error);
    }
    return { report: result.value, timestamp };
  }
  createTask(command) {
    return this.execTW(`add ${command}`).map((v) => this.parseCreationModificationOutput(v)).andThen((v) => {
      if (v.length === 0)
        return err(new Error("No task created"));
      if (v.length > 1)
        throw err(new Error("Assertion failed: multiple tasks created"));
      return ok(v[0]);
    }).andThen((v) => this.getUuidOfTask(v));
  }
  async modifyTask(uuid, command) {
    const result = await this.execTW(`${uuid} modify ${command}`);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async deleteTask(uuid) {
    const result = await this.setTaskStatus(uuid, "deleted");
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
  }
  async completeTask(uuid) {
    const result = await this.execTW([uuid, "done"]);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
  }
  async undoTask(uuid) {
    this.setTaskStatus(uuid, "pending");
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
  }
  getUuidOfTask(id) {
    return this.execTW(["_get", `${id}.uuid`]).map((v) => v.trim());
  }
  parseCreationModificationOutput(output) {
    const lines = output.trim().split(/\n\r?/);
    return lines.map((l) => {
      var _a, _b;
      return (_b = (_a = /task (?<id>[0-9]+)/.exec(lines[0])) == null ? void 0 : _a.groups) == null ? void 0 : _b.id;
    }).filter((v) => v !== void 0 && v !== null);
  }
  async undo() {
    const result = await this.execTW(["rc.confirmation:0", "undo"]);
    if (result.isErr())
      return new import_obsidian.Notice("Error trying to undo last action");
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    new import_obsidian.Notice("Last action undone");
  }
};
function linearSearchOcurrence(search, array) {
  const indices = [];
  for (let i = 0; i < array.length; i++) {
    if (array[i] === search)
      indices.push(i);
  }
  indices.push(array.length);
  return indices;
}
function sliceUsingSeparatorIndexes(input, indexes) {
  const result = [];
  let prevOcurrence = 0;
  for (let i = 0; i < indexes.length; i++) {
    result.push(input.slice(prevOcurrence, indexes[i]));
    prevOcurrence = indexes[i];
  }
  return result;
}

// src/ui/TaskList.svelte
var import_obsidian7 = require("obsidian");

// src/modals.ts
var import_obsidian4 = require("obsidian");

// src/ui/TaskCreate.svelte
var import_obsidian2 = require("obsidian");

// src/util.ts
var TWPluginLogger = class {
  constructor(debugMode = false) {
    this.setDebugMode(debugMode);
  }
  setDebugMode(debugMode) {
    if (debugMode) {
      this.debug_log = this._internalLog;
    } else {
      this.debug_log = () => {
      };
    }
  }
  _internalLog(msg, ...optionalParams) {
    console.log(msg, ...optionalParams);
  }
  debug_log(msg, ...optionalParams) {
  }
  error_log(msg, ...optionalParams) {
    console.error(msg, ...optionalParams);
  }
};
function sanitizeSingleArgument(input) {
  return `"${input.replace(/"/g, '\\"')}"`;
}
function sanitize(input) {
  return sanitizeArguments(userArguments(input));
}
function sanitizeArguments(userArguments2) {
  return userArguments2.map((arg) => `"${arg.replace(/"/g, '\\"')}"`).join(" ");
}
function hexToHSL(Hex) {
  let r, g, b;
  if (Hex.length == 4) {
    r = "0x" + Hex[1] + Hex[1];
    g = "0x" + Hex[2] + Hex[2];
    b = "0x" + Hex[3] + Hex[3];
  } else if (Hex.length == 7) {
    r = "0x" + Hex[1] + Hex[2];
    g = "0x" + Hex[3] + Hex[4];
    b = "0x" + Hex[5] + Hex[6];
  }
  r = r / 255;
  g = g / 255;
  b = b / 255;
  let cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin, h = 0, s = 0, l = 0;
  if (delta == 0)
    h = 0;
  else if (cmax == r)
    h = (g - b) / delta % 6;
  else if (cmax == g)
    h = (b - r) / delta + 2;
  else
    h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0)
    h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return [h, s, l];
}
var hexToHSLCache = /* @__PURE__ */ new Map();
function memoizedHexToHSL(hex) {
  const cachedResult = hexToHSLCache.get(hex);
  if (cachedResult !== void 0)
    return cachedResult;
  const hsl = hexToHSL(hex);
  hexToHSLCache.set(hex, hsl);
  return hsl;
}
function hslLerp(a, b, t) {
  const h = a[0] + (b[0] - a[0]) * t;
  const s = a[1] + (b[1] - a[1]) * t;
  const l = a[2] + (b[2] - a[2]) * t;
  return [h, s, l];
}
function threeColorHslLerp(a, b, c, t) {
  const clampedT = Math.min(1, Math.max(0, t));
  if (clampedT < 0.5) {
    return hslLerp(a, b, clampedT * 2);
  } else {
    return hslLerp(b, c, (clampedT - 0.5) * 2);
  }
}
function userArguments(input) {
  const args = [];
  let current = "";
  let quoted = false;
  let escaped = false;
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    if (char === " " && !quoted && !escaped) {
      args.push(current);
      current = "";
    } else if (char === '"' && !escaped) {
      quoted = !quoted;
    } else if (char === "\\" && !escaped) {
      escaped = true;
    } else if (char !== '"' && escaped) {
      current += "\\" + char;
      escaped = false;
    } else {
      current += char;
      escaped = false;
    }
  }
  if (current !== "") {
    args.push(current);
  }
  return args;
}

// src/ui/TaskCreate.svelte
function add_css(target) {
  append_styles(target, "svelte-1lsetpq", ".hidden.svelte-1lsetpq{display:none}.actions-container.svelte-1lsetpq{display:flex}.action-button.svelte-1lsetpq{margin-left:auto}.command.svelte-1lsetpq{font-family:monospace;font-size:0.8em;color:var(--text-muted)}.uuid-text.svelte-1lsetpq{font-size:0.8em;color:var(--text-muted);background-color:var(--background-secondary-alt)}");
}
function create_fragment(ctx) {
  var _a;
  let div1;
  let label;
  let t1;
  let input_1;
  let autoFocus_action;
  let t2;
  let p;
  let t3;
  let t4;
  let div0;
  let button0;
  let t5;
  let t6;
  let t7;
  let pre;
  let t9;
  let html_tag;
  let raw_value = ((_a = (0, import_obsidian2.getIcon)("copy")) == null ? void 0 : _a.outerHTML) + "";
  let t10;
  let button1;
  let t11;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = "Name and modifiers";
      t1 = space();
      input_1 = element("input");
      t2 = space();
      p = element("p");
      t3 = text(
        /*command*/
        ctx[2]
      );
      t4 = space();
      div0 = element("div");
      button0 = element("button");
      t5 = text("UUID: ");
      t6 = text(
        /*createdUuid*/
        ctx[3]
      );
      t7 = space();
      pre = element("pre");
      pre.textContent = " ";
      t9 = space();
      html_tag = new HtmlTag(false);
      t10 = space();
      button1 = element("button");
      t11 = text("Create");
      attr(label, "for", "create-command");
      attr(input_1, "tabindex", "0");
      attr(input_1, "id", "create-command");
      attr(input_1, "type", "text");
      attr(input_1, "placeholder", "My new task priority:L");
      attr(p, "class", "command svelte-1lsetpq");
      attr(p, "id", "command-to-run");
      html_tag.a = null;
      attr(button0, "class", "uuid-text svelte-1lsetpq");
      toggle_class(button0, "hidden", !/*createdUuid*/
      ctx[3]);
      attr(button1, "class", "action-button svelte-1lsetpq");
      button1.disabled = button1_disabled_value = !/*readyToCreate*/
      ctx[4];
      attr(div0, "class", "actions-container svelte-1lsetpq");
      attr(div1, "role", "textbox");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[0]
      );
      append(div1, t2);
      append(div1, p);
      append(p, t3);
      append(div1, t4);
      append(div1, div0);
      append(div0, button0);
      append(button0, t5);
      append(button0, t6);
      append(button0, t7);
      append(button0, pre);
      append(button0, t9);
      html_tag.m(raw_value, button0);
      append(div0, t10);
      append(div0, button1);
      append(button1, t11);
      if (!mounted) {
        dispose = [
          action_destroyer(autoFocus_action = autoFocus.call(null, input_1)),
          listen(
            input_1,
            "keyup",
            /*keyup_handler*/
            ctx[12]
          ),
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[13]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[14]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*input*/
      1 && input_1.value !== /*input*/
      ctx2[0]) {
        set_input_value(
          input_1,
          /*input*/
          ctx2[0]
        );
      }
      if (dirty & /*command*/
      4)
        set_data(
          t3,
          /*command*/
          ctx2[2]
        );
      if (dirty & /*createdUuid*/
      8)
        set_data(
          t6,
          /*createdUuid*/
          ctx2[3]
        );
      if (dirty & /*createdUuid*/
      8) {
        toggle_class(button0, "hidden", !/*createdUuid*/
        ctx2[3]);
      }
      if (dirty & /*readyToCreate*/
      16 && button1_disabled_value !== (button1_disabled_value = !/*readyToCreate*/
      ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function autoFocus(node) {
  node.focus();
}
function instance($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { titleElement } = $$props;
  let { template } = $$props;
  let { close } = $$props;
  let state = "ok";
  let input;
  let command;
  let trueInput;
  let createdUuid = void 0;
  let readyToCreate = false;
  async function createTask(cmd) {
    $$invalidate(11, state = "loading");
    await plugin.handler.createTask(cmd).match(
      (v) => {
        new import_obsidian2.Notice(`Task ${v} created.`);
        $$invalidate(3, createdUuid = v);
        plugin.emitter.emit("pending-refresh" /* REFRESH */);
      },
      (err2) => {
        new import_obsidian2.Notice(`Error creating task: ${err2}`);
        $$invalidate(11, state = "error");
      }
    );
  }
  onMount(() => {
    titleElement.setText("Create New Task");
  });
  function closeModal() {
    close();
  }
  async function copyToClipboard(c) {
    await navigator.clipboard.writeText(c);
    new import_obsidian2.Notice("Copied to clipboard");
  }
  const keyup_handler = (e) => e.key === "Enter" && readyToCreate && createTask(trueInput);
  function input_1_input_handler() {
    input = this.value;
    $$invalidate(0, input);
  }
  const click_handler = () => copyToClipboard(createdUuid || "");
  const click_handler_1 = () => createTask(trueInput);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(7, plugin = $$props2.plugin);
    if ("titleElement" in $$props2)
      $$invalidate(8, titleElement = $$props2.titleElement);
    if ("template" in $$props2)
      $$invalidate(9, template = $$props2.template);
    if ("close" in $$props2)
      $$invalidate(10, close = $$props2.close);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*input, template*/
    513) {
      $: {
        $$invalidate(1, trueInput = `${sanitize(input || "")}${template ? " " + sanitize(template) : ""}`);
      }
    }
    if ($$self.$$.dirty & /*trueInput*/
    2) {
      $: {
        $$invalidate(2, command = `task add ${trueInput}`);
      }
    }
    if ($$self.$$.dirty & /*state, input*/
    2049) {
      $: {
        $$invalidate(4, readyToCreate = state !== "loading" && input !== void 0 && input !== "");
      }
    }
  };
  return [
    input,
    trueInput,
    command,
    createdUuid,
    readyToCreate,
    createTask,
    copyToClipboard,
    plugin,
    titleElement,
    template,
    close,
    state,
    keyup_handler,
    input_1_input_handler,
    click_handler,
    click_handler_1
  ];
}
var TaskCreate = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        plugin: 7,
        titleElement: 8,
        template: 9,
        close: 10
      },
      add_css
    );
  }
};
var TaskCreate_default = TaskCreate;

// src/ui/TaskModify.svelte
var import_obsidian3 = require("obsidian");
function add_css2(target) {
  append_styles(target, "svelte-97yl9f", ".actions-container.svelte-97yl9f{display:flex}.action-button.svelte-97yl9f{margin-left:auto}.command.svelte-97yl9f{font-family:monospace;font-size:0.8em;color:var(--text-muted)}.uuid-text.svelte-97yl9f{font-size:0.8em;color:var(--text-muted);background-color:var(--background-secondary-alt)}");
}
function create_fragment2(ctx) {
  var _a;
  let div1;
  let label;
  let t1;
  let input_1;
  let input_1_placeholder_value;
  let autoFocus_action;
  let t2;
  let p;
  let t3;
  let t4;
  let div0;
  let button0;
  let t5;
  let t6_value = (
    /*task*/
    ctx[0].uuid + ""
  );
  let t6;
  let t7;
  let pre;
  let t9;
  let html_tag;
  let raw_value = ((_a = (0, import_obsidian3.getIcon)("copy")) == null ? void 0 : _a.outerHTML) + "";
  let t10;
  let button1;
  let t11;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = "Name and modifiers";
      t1 = space();
      input_1 = element("input");
      t2 = space();
      p = element("p");
      t3 = text(
        /*command*/
        ctx[3]
      );
      t4 = space();
      div0 = element("div");
      button0 = element("button");
      t5 = text("UUID: ");
      t6 = text(t6_value);
      t7 = space();
      pre = element("pre");
      pre.textContent = " ";
      t9 = space();
      html_tag = new HtmlTag(false);
      t10 = space();
      button1 = element("button");
      t11 = text("Modify");
      attr(label, "for", "modify-command");
      attr(input_1, "tabindex", "0");
      attr(input_1, "id", "modify-command");
      attr(input_1, "type", "text");
      attr(input_1, "placeholder", input_1_placeholder_value = /*task*/
      (ctx[0].taskName ? (
        /*task*/
        ctx[0].taskName
      ) : "My Task") + " due:tomorrow");
      attr(p, "class", "command svelte-97yl9f");
      attr(p, "id", "command-to-run");
      html_tag.a = null;
      attr(button0, "class", "uuid-text svelte-97yl9f");
      attr(button1, "class", "action-button svelte-97yl9f");
      button1.disabled = button1_disabled_value = !/*readyToModify*/
      ctx[4];
      attr(div0, "class", "actions-container svelte-97yl9f");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[1]
      );
      append(div1, t2);
      append(div1, p);
      append(p, t3);
      append(div1, t4);
      append(div1, div0);
      append(div0, button0);
      append(button0, t5);
      append(button0, t6);
      append(button0, t7);
      append(button0, pre);
      append(button0, t9);
      html_tag.m(raw_value, button0);
      append(div0, t10);
      append(div0, button1);
      append(button1, t11);
      if (!mounted) {
        dispose = [
          action_destroyer(autoFocus_action = autoFocus2.call(null, input_1)),
          listen(
            input_1,
            "keyup",
            /*keyup_handler*/
            ctx[11]
          ),
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[12]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[13]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*task*/
      1 && input_1_placeholder_value !== (input_1_placeholder_value = /*task*/
      (ctx2[0].taskName ? (
        /*task*/
        ctx2[0].taskName
      ) : "My Task") + " due:tomorrow")) {
        attr(input_1, "placeholder", input_1_placeholder_value);
      }
      if (dirty & /*input*/
      2 && input_1.value !== /*input*/
      ctx2[1]) {
        set_input_value(
          input_1,
          /*input*/
          ctx2[1]
        );
      }
      if (dirty & /*command*/
      8)
        set_data(
          t3,
          /*command*/
          ctx2[3]
        );
      if (dirty & /*task*/
      1 && t6_value !== (t6_value = /*task*/
      ctx2[0].uuid + ""))
        set_data(t6, t6_value);
      if (dirty & /*readyToModify*/
      16 && button1_disabled_value !== (button1_disabled_value = !/*readyToModify*/
      ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function autoFocus2(node) {
  node.focus();
}
function instance2($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { task } = $$props;
  let { titleElement } = $$props;
  let { close } = $$props;
  let state = "ok";
  let input;
  let sanitizedInput;
  let command;
  let readyToModify;
  async function modifyTask(cmd) {
    $$invalidate(10, state = "loading");
    (await plugin.handler.modifyTask(task.uuid, cmd)).match(
      (v) => {
        $$invalidate(10, state = "ok");
        new import_obsidian3.Notice(`Task ${task.uuid} modified.`);
        plugin.emitter.emit("pending-refresh" /* REFRESH */);
      },
      (err2) => {
        $$invalidate(10, state = "error");
        new import_obsidian3.Notice(`Could not modify task ${task.uuid}!`, 5e3);
      }
    );
    close();
  }
  onMount(() => {
    titleElement.setText(`Modify task ${task.taskName || task.uuid}`);
  });
  async function copyToClipboard(c) {
    await navigator.clipboard.writeText(c);
    new import_obsidian3.Notice("Copied to clipboard");
  }
  const keyup_handler = (e) => e.key === "Enter" && readyToModify && modifyTask(sanitizedInput);
  function input_1_input_handler() {
    input = this.value;
    $$invalidate(1, input);
  }
  const click_handler = () => copyToClipboard(task.uuid);
  const click_handler_1 = () => modifyTask(sanitizedInput);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(7, plugin = $$props2.plugin);
    if ("task" in $$props2)
      $$invalidate(0, task = $$props2.task);
    if ("titleElement" in $$props2)
      $$invalidate(8, titleElement = $$props2.titleElement);
    if ("close" in $$props2)
      $$invalidate(9, close = $$props2.close);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*input*/
    2) {
      $: {
        $$invalidate(2, sanitizedInput = sanitize(input || ""));
      }
    }
    if ($$self.$$.dirty & /*task, sanitizedInput*/
    5) {
      $: {
        $$invalidate(3, command = `task ${task.uuid} modify ${sanitizedInput}`);
      }
    }
    if ($$self.$$.dirty & /*state, input*/
    1026) {
      $: {
        $$invalidate(4, readyToModify = state !== "loading" && input !== void 0 && input !== "");
      }
    }
  };
  return [
    task,
    input,
    sanitizedInput,
    command,
    readyToModify,
    modifyTask,
    copyToClipboard,
    plugin,
    titleElement,
    close,
    state,
    keyup_handler,
    input_1_input_handler,
    click_handler,
    click_handler_1
  ];
}
var TaskModify = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        plugin: 7,
        task: 0,
        titleElement: 8,
        close: 9
      },
      add_css2
    );
  }
};
var TaskModify_default = TaskModify;

// src/modals.ts
var TWPModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
};
var CreateTaskModal = class extends TWPModal {
  constructor(app, plugin, template) {
    super(app, plugin);
    this.template = template;
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    this.ctModal = new TaskCreate_default({
      target: contentEl,
      props: {
        close: () => this.close(),
        plugin: this.plugin,
        titleElement: titleEl,
        template: this.template
      }
    });
  }
  onClose() {
    var _a;
    (_a = this.ctModal) == null ? void 0 : _a.$destroy();
    const { contentEl } = this;
    contentEl.empty();
  }
};
var UpdateTaskModal = class extends TWPModal {
  constructor(app, plugin, task) {
    super(app, plugin);
    this.task = task;
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    this.ctModal = new TaskModify_default({
      target: contentEl,
      props: {
        close: () => this.close(),
        plugin: this.plugin,
        task: this.task,
        titleElement: titleEl
      }
    });
  }
  onClose() {
    var _a;
    (_a = this.ctModal) == null ? void 0 : _a.$destroy();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/CustomActionMenu.ts
var import_obsidian5 = require("obsidian");
function runCommandOnTask(taskUuid, command, plugin) {
  plugin.handler.modifyTask(taskUuid, command).then(() => {
    new import_obsidian5.Notice(`Task ${taskUuid} modified.`);
    plugin.emitter.emit("pending-refresh" /* REFRESH */);
  }).catch(() => {
    new import_obsidian5.Notice(`Could not modify task ${taskUuid}!`, 5e3);
  });
}
function showActionMenu(taskUuid, event, plugin) {
  event.preventDefault();
  const menu = new import_obsidian5.Menu();
  for (const action of plugin.settings.right_click_context_menu_actions.values()) {
    menu.addItem(
      (item) => item.setTitle(action.ActionName).setIcon("documents").onClick(() => {
        runCommandOnTask(taskUuid, action.Action, plugin);
      })
    );
  }
  menu.showAtMouseEvent(event);
}

// src/ui/col/status.svelte
var import_obsidian6 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-ijdzoh", ".small-checkbox.svelte-ijdzoh{margin:0}.small-delete-button.svelte-ijdzoh{padding:2px;margin:0;overflow:hidden;flex-shrink:0;border-radius:var(--checkbox-radius);border:1px solid var(--checkbox-border-color);height:var(--checkbox-size);width:var(--checkbox-size)}.center-td.svelte-ijdzoh{text-align:center}");
}
function create_else_block_1(ctx) {
  var _a;
  let td;
  let button;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)("cross")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      button = element("button");
      button.disabled = /*disabled*/
      ctx[1];
      attr(button, "class", "small-delete-button svelte-ijdzoh");
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, button);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  var _a;
  let td;
  let button;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)("undo")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      button = element("button");
      button.disabled = /*disabled*/
      ctx[1];
      attr(button, "class", "small-delete-button svelte-ijdzoh");
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, button);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*status*/
      ctx2[0] === "D"
    )
      return create_if_block_1;
    if (
      /*status*/
      ctx2[0] === "R"
    )
      return create_if_block_2;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block(ctx) {
  let td;
  let input;
  let input_checked_value;
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      input = element("input");
      input.disabled = /*disabled*/
      ctx[1];
      attr(input, "class", "small-checkbox svelte-ijdzoh");
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = /*status*/
      ctx[0] === "C";
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, input);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*change_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        input.disabled = /*disabled*/
        ctx2[1];
      }
      if (dirty & /*status*/
      1 && input_checked_value !== (input_checked_value = /*status*/
      ctx2[0] === "C")) {
        input.checked = input_checked_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2(ctx) {
  let td;
  return {
    c() {
      td = element("td");
      td.innerHTML = ``;
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(td);
      }
    }
  };
}
function create_if_block_1(ctx) {
  var _a;
  let td;
  let button;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)("undo")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      button = element("button");
      button.disabled = /*disabled*/
      ctx[1];
      attr(button, "class", "small-delete-button svelte-ijdzoh");
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, button);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*altVersion*/
    ctx2[2])
      return create_if_block;
    if (
      /*status*/
      ctx2[0] === "D"
    )
      return create_if_block_3;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function isChecked(e) {
  return e.target.checked;
}
function instance3($$self, $$props, $$invalidate) {
  let { status } = $$props;
  let { disabled = void 0 } = $$props;
  let { altVersion = false } = $$props;
  const dispatch = createEventDispatcher();
  function notifyChange(newStatus) {
    dispatch("statusChange", newStatus);
    $$invalidate(0, status = newStatus);
  }
  const click_handler = () => notifyChange("P");
  const change_handler = (e) => isChecked(e) ? notifyChange("C") : notifyChange("P");
  const click_handler_1 = () => notifyChange("P");
  const click_handler_2 = () => notifyChange("D");
  $$self.$$set = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(0, status = $$props2.status);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("altVersion" in $$props2)
      $$invalidate(2, altVersion = $$props2.altVersion);
  };
  return [
    status,
    disabled,
    altVersion,
    notifyChange,
    click_handler,
    change_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Status = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { status: 0, disabled: 1, altVersion: 2 }, add_css3);
  }
};
var status_default = Status;

// node_modules/timeago.js/esm/lang/en_US.js
var EN_US = ["second", "minute", "hour", "day", "week", "month", "year"];
function en_US_default(diff, idx) {
  if (idx === 0)
    return ["just now", "right now"];
  var unit = EN_US[Math.floor(idx / 2)];
  if (diff > 1)
    unit += "s";
  return [diff + " " + unit + " ago", "in " + diff + " " + unit];
}

// node_modules/timeago.js/esm/lang/zh_CN.js
var ZH_CN = ["\u79D2", "\u5206\u949F", "\u5C0F\u65F6", "\u5929", "\u5468", "\u4E2A\u6708", "\u5E74"];
function zh_CN_default(diff, idx) {
  if (idx === 0)
    return ["\u521A\u521A", "\u7247\u523B\u540E"];
  var unit = ZH_CN[~~(idx / 2)];
  return [diff + " " + unit + "\u524D", diff + " " + unit + "\u540E"];
}

// node_modules/timeago.js/esm/register.js
var Locales = {};
var register = function(locale, func) {
  Locales[locale] = func;
};
var getLocale = function(locale) {
  return Locales[locale] || Locales["en_US"];
};

// node_modules/timeago.js/esm/utils/date.js
var SEC_ARRAY = [
  60,
  60,
  24,
  7,
  365 / 7 / 12,
  12
];
function toDate(input) {
  if (input instanceof Date)
    return input;
  if (!isNaN(input) || /^\d+$/.test(input))
    return new Date(parseInt(input));
  input = (input || "").trim().replace(/\.\d+/, "").replace(/-/, "/").replace(/-/, "/").replace(/(\d)T(\d)/, "$1 $2").replace(/Z/, " UTC").replace(/([+-]\d\d):?(\d\d)/, " $1$2");
  return new Date(input);
}
function formatDiff(diff, localeFunc) {
  var agoIn = diff < 0 ? 1 : 0;
  diff = Math.abs(diff);
  var totalSec = diff;
  var idx = 0;
  for (; diff >= SEC_ARRAY[idx] && idx < SEC_ARRAY.length; idx++) {
    diff /= SEC_ARRAY[idx];
  }
  diff = Math.floor(diff);
  idx *= 2;
  if (diff > (idx === 0 ? 9 : 1))
    idx += 1;
  return localeFunc(diff, idx, totalSec)[agoIn].replace("%s", diff.toString());
}
function diffSec(date, relativeDate) {
  var relDate = relativeDate ? toDate(relativeDate) : new Date();
  return (+relDate - +toDate(date)) / 1e3;
}

// node_modules/timeago.js/esm/format.js
var format = function(date, locale, opts) {
  var sec = diffSec(date, opts && opts.relativeDate);
  return formatDiff(sec, getLocale(locale));
};

// node_modules/timeago.js/esm/index.js
register("en_US", en_US_default);
register("zh_CN", zh_CN_default);

// src/ui/col/tags.svelte
var import_crypto = require("crypto");
function add_css4(target) {
  append_styles(target, "svelte-k8lobp", ".pill-container.svelte-k8lobp{display:flex;flex-wrap:wrap;justify-content:center}.accent-1.svelte-k8lobp{color:var(--accent-1);background-color:rgba(var(--accent-1-rgb), 0.1)}.accent-2.svelte-k8lobp{color:var(--accent-2);background-color:rgba(var(--accent-2-rgb), 0.1)}.accent-3.svelte-k8lobp{color:var(--accent-3);background-color:rgba(var(--accent-3-rgb), 0.1)}.accent-4.svelte-k8lobp{color:var(--accent-4);background-color:rgba(var(--accent-4-rgb), 0.1)}.accent-5.svelte-k8lobp{color:var(--accent-5);background-color:rgba(var(--accent-5-rgb), 0.1)}.accent-6.svelte-k8lobp{color:var(--accent-6);background-color:rgba(var(--accent-6-rgb), 0.1)}.pill-class.svelte-k8lobp{display:inline-block;padding:0.25em 0.25em;margin:0.1em;border-radius:var(--pill-radius);font-weight:var(--pill-weight);font-size:var(--metadata-input-font-size);justify-content:center}.center-td.svelte-k8lobp{text-align:center}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*tagsArr*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "pill-container svelte-k8lobp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*textToId6, tagsArr*/
      3) {
        each_value = ensure_array_like(
          /*tagsArr*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t_value = (
    /*tag*/
    ctx[4] + ""
  );
  let t;
  let div_class_value;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", div_class_value = `pill-class accent-${/*textToId6*/
      ctx[1](
        /*tag*/
        ctx[4]
      ) + 1} svelte-k8lobp`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*tagsArr*/
      1 && t_value !== (t_value = /*tag*/
      ctx2[4] + ""))
        set_data(t, t_value);
      if (dirty & /*tagsArr*/
      1 && div_class_value !== (div_class_value = `pill-class accent-${/*textToId6*/
      ctx2[1](
        /*tag*/
        ctx2[4]
      ) + 1} svelte-k8lobp`)) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment4(ctx) {
  let td;
  let if_block = (
    /*tagsArr*/
    ctx[0].length !== 0 && create_if_block2(ctx)
  );
  return {
    c() {
      td = element("td");
      if (if_block)
        if_block.c();
      attr(td, "class", "center-td svelte-k8lobp");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (if_block)
        if_block.m(td, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*tagsArr*/
        ctx2[0].length !== 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(td, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { tags } = $$props;
  let tagsArr;
  const dispatch = createEventDispatcher();
  function textToId6(text2) {
    return (0, import_crypto.createHash)("sha1").update(text2).digest().readUint8(0) % 6;
  }
  $$self.$$set = ($$props2) => {
    if ("tags" in $$props2)
      $$invalidate(2, tags = $$props2.tags);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tags*/
    4) {
      $: {
        $$invalidate(0, tagsArr = tags ? tags.split(" ") : []);
      }
    }
  };
  return [tagsArr, textToId6, tags];
}
var Tags = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { tags: 2 }, add_css4);
  }
};
var tags_default = Tags;

// src/ui/col/urgency.svelte
function add_css5(target) {
  append_styles(target, "svelte-l4yssk", ".pill-container.svelte-l4yssk{display:flex;flex-wrap:wrap;justify-content:center}.pill-class.svelte-l4yssk{display:inline-block;padding:0.25em 0.25em;margin:0.1em;border-radius:var(--pill-radius);font-weight:var(--pill-weight);font-size:var(--metadata-input-font-size);justify-content:center}.center-td.svelte-l4yssk{text-align:center}");
}
function create_fragment5(ctx) {
  let td;
  let div1;
  let div0;
  let t;
  return {
    c() {
      td = element("td");
      div1 = element("div");
      div0 = element("div");
      t = text(
        /*urgency*/
        ctx[0]
      );
      set_style(div0, "color", colorHSLToString(
        /*urgencyColor*/
        ctx[1]
      ));
      set_style(div0, "background-color", colorHSLToString(
        /*urgencyColor*/
        ctx[1],
        0.1
      ));
      attr(div0, "class", "pill-class svelte-l4yssk");
      attr(div1, "class", "pill-container svelte-l4yssk");
      attr(td, "class", "center-td svelte-l4yssk");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, div1);
      append(div1, div0);
      append(div0, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*urgency*/
      1)
        set_data(
          t,
          /*urgency*/
          ctx2[0]
        );
      if (dirty & /*urgencyColor*/
      2) {
        set_style(div0, "color", colorHSLToString(
          /*urgencyColor*/
          ctx2[1]
        ));
      }
      if (dirty & /*urgencyColor*/
      2) {
        set_style(div0, "background-color", colorHSLToString(
          /*urgencyColor*/
          ctx2[1],
          0.1
        ));
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(td);
      }
    }
  };
}
function colorHSLToString(color, alpha = 1) {
  return `hsla(${color[0]}, ${color[1]}%, ${color[2]}%, ${alpha})`;
}
function instance5($$self, $$props, $$invalidate) {
  let { urgency } = $$props;
  let aColorHSL = memoizedHexToHSL(document.body.getCssPropertyValue("--color-red"));
  let bColorHSL = memoizedHexToHSL(document.body.getCssPropertyValue("--color-yellow"));
  let cColorHSL = memoizedHexToHSL(document.body.getCssPropertyValue("--color-green"));
  let urgencyValue;
  let urgencyColor;
  onMount(() => {
    $$invalidate(2, urgencyValue = parseFloat(urgency) / 10);
    $$invalidate(1, urgencyColor = threeColorHslLerp(cColorHSL, bColorHSL, aColorHSL, urgencyValue));
  });
  $$self.$$set = ($$props2) => {
    if ("urgency" in $$props2)
      $$invalidate(0, urgency = $$props2.urgency);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*urgency*/
    1) {
      $: {
        $$invalidate(2, urgencyValue = (parseFloat(urgency) + 5) / 20);
      }
    }
    if ($$self.$$.dirty & /*urgencyValue*/
    4) {
      $: {
        $$invalidate(1, urgencyColor = threeColorHslLerp(cColorHSL, bColorHSL, aColorHSL, urgencyValue));
      }
    }
  };
  return [urgency, urgencyColor, urgencyValue];
}
var Urgency = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { urgency: 0 }, add_css5);
  }
};
var urgency_default = Urgency;

// src/ui/TaskList.svelte
function add_css6(target) {
  append_styles(target, "svelte-joxkzl", ".loader.svelte-joxkzl.svelte-joxkzl{padding:4px;display:flex;justify-content:space-between;align-items:center;background-color:#00000034}.task-hover.svelte-joxkzl.svelte-joxkzl:hover{background-color:var(--table-selection)}.padding-horizontal.svelte-joxkzl.svelte-joxkzl{padding-left:1em;padding-right:1em}.padder.svelte-joxkzl.svelte-joxkzl{padding:8px}.error.svelte-joxkzl.svelte-joxkzl{color:lightcoral}.row-disabled.svelte-joxkzl.svelte-joxkzl{text-decoration:line-through;color:var(--color-base-50)}.unimportant.svelte-joxkzl.svelte-joxkzl{color:var(--color-comment);font-size:var(--font-smallest)}.refresh-container.svelte-joxkzl.svelte-joxkzl{display:flex;align-items:center}.report.svelte-joxkzl.svelte-joxkzl{padding-left:4px;padding-right:4px}.data.svelte-joxkzl.svelte-joxkzl{overflow-x:auto;min-width:none}.tw-table.svelte-joxkzl.svelte-joxkzl{width:100%;border-collapse:collapse;margin:0;border:0}.tw-table.svelte-joxkzl th.svelte-joxkzl,.tw-table.svelte-joxkzl td.svelte-joxkzl{min-width:1ch !important;font-size:var(--font-smaller)}.refresh-button.svelte-joxkzl.svelte-joxkzl{cursor:pointer}.refresh-button.svelte-joxkzl.svelte-joxkzl:hover{text-decoration:underline}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[27] = list;
  child_ctx[28] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function create_if_block_8(ctx) {
  var _a;
  let button;
  let raw_value = ((_a = (0, import_obsidian7.getIcon)("plus")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[18]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7(ctx) {
  let span;
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("updated ");
      t1 = text(
        /*formattedAgo*/
        ctx[8]
      );
      attr(span, "class", "report unimportant padding-horizontal svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*formattedAgo*/
      256)
        set_data(
          t1,
          /*formattedAgo*/
          ctx2[8]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "error fetching tasks";
      attr(span, "class", "report unimportant error padding-horizontal svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "loading...";
      attr(span, "class", "report unimportant padding-horizontal svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_12, create_if_block_22, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*reportList*/
      ctx2[5].columns.length <= 2
    )
      return 0;
    if (
      /*reportList*/
      ctx2[5].tasks.length === 0
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block2(ctx) {
  let table;
  let thead;
  let tr;
  let th;
  let t0;
  let t1;
  let tbody;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_2 = ensure_array_like(
    /*reportList*/
    ctx[5].printedColumns
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = ensure_array_like(
    /*reportList*/
    ctx[5].tasks
  );
  const get_key = (ctx2) => (
    /*task*/
    ctx2[26].uuid
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th = element("th");
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(th, "class", "svelte-joxkzl");
      attr(table, "class", "tw-table svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(thead, tr);
      append(tr, th);
      append(tr, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append(table, t1);
      append(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*reportList*/
      32) {
        each_value_2 = ensure_array_like(
          /*reportList*/
          ctx2[5].printedColumns
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & /*reportList, plugin, deleteKeyDown, handleStatusChange*/
      4193) {
        each_value = ensure_array_like(
          /*reportList*/
          ctx2[5].tasks
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each1_lookup, tbody, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      destroy_each(each_blocks_1, detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block_22(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span>No tasks found in report.</span>`;
      attr(div, "class", "padder error svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span>Report does not seem to exist.</span>`;
      attr(div, "class", "padder error svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let th;
  let t_value = (
    /*pColumns*/
    ctx[32].label + ""
  );
  let t;
  return {
    c() {
      th = element("th");
      t = text(t_value);
      attr(th, "class", "svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*reportList*/
      32 && t_value !== (t_value = /*pColumns*/
      ctx2[32].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
function create_else_block_12(ctx) {
  let td;
  let t_value = (
    /*data*/
    ctx[29] + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[21](
        /*task*/
        ctx[26]
      )
    );
  }
  return {
    c() {
      td = element("td");
      t = text(t_value);
      attr(td, "class", "svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
      if (!mounted) {
        dispose = listen(td, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*reportList*/
      32 && t_value !== (t_value = /*data*/
      ctx[29] + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4(ctx) {
  let urgency;
  let current;
  urgency = new urgency_default({ props: { urgency: (
    /*data*/
    ctx[29]
  ) } });
  return {
    c() {
      create_component(urgency.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urgency, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urgency_changes = {};
      if (dirty[0] & /*reportList*/
      32)
        urgency_changes.urgency = /*data*/
        ctx2[29];
      urgency.$set(urgency_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urgency.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urgency.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urgency, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let tags;
  let current;
  tags = new tags_default({ props: { tags: (
    /*data*/
    ctx[29]
  ) } });
  return {
    c() {
      create_component(tags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tags_changes = {};
      if (dirty[0] & /*reportList*/
      32)
        tags_changes.tags = /*data*/
        ctx2[29];
      tags.$set(tags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tags, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_32, create_if_block_4, create_else_block_12];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*reportList*/
      ctx2[5].printedColumns[
        /*dIndex*/
        ctx2[31]
      ].type === "tags"
    )
      return 0;
    if (
      /*reportList*/
      ctx2[5].printedColumns[
        /*dIndex*/
        ctx2[31]
      ].type === "urgency"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block2(key_1, ctx) {
  let tr;
  let status;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  function statusChange_handler(...args) {
    return (
      /*statusChange_handler*/
      ctx[20](
        /*task*/
        ctx[26],
        /*each_value*/
        ctx[27],
        /*tIndex*/
        ctx[28],
        ...args
      )
    );
  }
  status = new status_default({
    props: {
      disabled: (
        /*task*/
        ctx[26].disabled
      ),
      status: (
        /*task*/
        ctx[26].status
      ),
      altVersion: (
        /*deleteKeyDown*/
        ctx[6]
      )
    }
  });
  status.$on("statusChange", statusChange_handler);
  let each_value_1 = ensure_array_like(
    /*task*/
    ctx[26].data
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  function contextmenu_handler(...args) {
    return (
      /*contextmenu_handler*/
      ctx[22](
        /*task*/
        ctx[26],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      create_component(status.$$.fragment);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      attr(tr, "class", "task-hover svelte-joxkzl");
      toggle_class(
        tr,
        "row-disabled",
        /*task*/
        ctx[26].disabled
      );
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      mount_component(status, tr, null);
      append(tr, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append(tr, t1);
      current = true;
      if (!mounted) {
        dispose = listen(tr, "contextmenu", function() {
          if (is_function(
            /*plugin*/
            ctx[0].settings.right_click_context_menu_enabled ? contextmenu_handler : null
          ))
            /*plugin*/
            (ctx[0].settings.right_click_context_menu_enabled ? contextmenu_handler : null).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const status_changes = {};
      if (dirty[0] & /*reportList*/
      32)
        status_changes.disabled = /*task*/
        ctx[26].disabled;
      if (dirty[0] & /*reportList*/
      32)
        status_changes.status = /*task*/
        ctx[26].status;
      if (dirty[0] & /*deleteKeyDown*/
      64)
        status_changes.altVersion = /*deleteKeyDown*/
        ctx[6];
      status.$set(status_changes);
      if (dirty[0] & /*reportList, plugin*/
      33) {
        each_value_1 = ensure_array_like(
          /*task*/
          ctx[26].data
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tr, t1);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*reportList*/
      32) {
        toggle_class(
          tr,
          "row-disabled",
          /*task*/
          ctx[26].disabled
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(status.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(status.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      destroy_component(status);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment6(ctx) {
  var _a;
  let div4;
  let div2;
  let div0;
  let t0;
  let span;
  let t1_value = (
    /*report*/
    ctx[1] + " " + /*command*/
    ctx[2]
  );
  let t1;
  let t2;
  let div1;
  let t3;
  let t4;
  let t5;
  let button;
  let raw_value = ((_a = (0, import_obsidian7.getIcon)("rotate-cw")) == null ? void 0 : _a.outerHTML) + "";
  let t6;
  let div3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*newTaskTemplate*/
    ctx[3] && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*state*/
    ctx[4] === "ok" && create_if_block_7(ctx)
  );
  let if_block2 = (
    /*state*/
    ctx[4] === "error" && create_if_block_6(ctx)
  );
  let if_block3 = (
    /*state*/
    ctx[4] === "loading" && create_if_block_5(ctx)
  );
  let if_block4 = (
    /*reportList*/
    ctx[5] !== void 0 && create_if_block3(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      button = element("button");
      t6 = space();
      div3 = element("div");
      if (if_block4)
        if_block4.c();
      attr(span, "class", "unimportant padding-horizontal svelte-joxkzl");
      attr(div0, "class", "refresh-container svelte-joxkzl");
      attr(button, "class", "refresh-button svelte-joxkzl");
      attr(div1, "class", "refresh-container svelte-joxkzl");
      attr(div2, "class", "loader svelte-joxkzl");
      attr(div3, "class", "data svelte-joxkzl");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div2, t2);
      append(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      append(div1, t5);
      append(div1, button);
      button.innerHTML = raw_value;
      ctx[19](button);
      append(div4, t6);
      append(div4, div3);
      if (if_block4)
        if_block4.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "keydown",
            /*keydown_handler*/
            ctx[16]
          ),
          listen(
            window,
            "keyup",
            /*keyup_handler*/
            ctx[17]
          ),
          listen(
            button,
            "click",
            /*getTasks*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*newTaskTemplate*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty[0] & /*report, command*/
      6) && t1_value !== (t1_value = /*report*/
      ctx2[1] + " " + /*command*/
      ctx2[2]))
        set_data(t1, t1_value);
      if (
        /*state*/
        ctx2[4] === "ok"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*state*/
        ctx2[4] === "error"
      ) {
        if (if_block2) {
        } else {
          if_block2 = create_if_block_6(ctx2);
          if_block2.c();
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*state*/
        ctx2[4] === "loading"
      ) {
        if (if_block3) {
        } else {
          if_block3 = create_if_block_5(ctx2);
          if_block3.c();
          if_block3.m(div1, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*reportList*/
        ctx2[5] !== void 0
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*reportList*/
          32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block3(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div3, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[19](null);
      if (if_block4)
        if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { report } = $$props;
  let { sanitizedReport } = $$props;
  let { command } = $$props;
  let { sanitizedCommand } = $$props;
  let { newTaskTemplate } = $$props;
  let state = "loading";
  let reportList;
  let timestamp;
  let deleteKeyDown = false;
  let refreshButton;
  let formattedAgo;
  function formatTimestamp(timestamp2) {
    $$invalidate(8, formattedAgo = format(timestamp2));
  }
  async function getTasks() {
    var _a;
    $$invalidate(4, state = "loading");
    let result;
    try {
      result = await ((_a = plugin.handler) === null || _a === void 0 ? void 0 : _a.getTasks(sanitizedReport, sanitizedCommand));
    } catch (error) {
      $$invalidate(4, state = "error");
      plugin.logger.debug_log("Error fetching tasks", error);
      return;
    }
    $$invalidate(5, reportList = result.report);
    $$invalidate(15, timestamp = result.timestamp);
    $$invalidate(4, state = "ok");
  }
  function onDeleteKeyDown() {
    $$invalidate(6, deleteKeyDown = true);
  }
  function onDeleteKeyUp() {
    $$invalidate(6, deleteKeyDown = false);
  }
  async function handleStatusChange(uuid, e) {
    var _a, _b, _c, _d;
    switch (e.detail) {
      case "C":
        await ((_a = plugin.handler) === null || _a === void 0 ? void 0 : _a.completeTask(uuid));
        break;
      case "D":
        await ((_b = plugin.handler) === null || _b === void 0 ? void 0 : _b.deleteTask(uuid));
        break;
      case "P":
        await ((_c = plugin.handler) === null || _c === void 0 ? void 0 : _c.modifyTask(uuid, "status:pending"));
        break;
      case "R":
        await ((_d = plugin.handler) === null || _d === void 0 ? void 0 : _d.modifyTask(uuid, "status:recurring"));
        break;
      default:
        break;
    }
  }
  const refreshCallback = () => {
    getTasks();
  };
  const intervalCallback = () => {
    formatTimestamp(timestamp);
  };
  onMount(() => {
    var _a, _b;
    getTasks();
    (_a = plugin.emitter) === null || _a === void 0 ? void 0 : _a.on("pending-refresh" /* REFRESH */, refreshCallback);
    (_b = plugin.emitter) === null || _b === void 0 ? void 0 : _b.on("interval-fetch" /* INTERVAL */, intervalCallback);
  });
  onDestroy(() => {
    var _a, _b;
    (_a = plugin.emitter) === null || _a === void 0 ? void 0 : _a.off("pending-refresh" /* REFRESH */, refreshCallback);
    (_b = plugin.emitter) === null || _b === void 0 ? void 0 : _b.off("interval-fetch" /* INTERVAL */, intervalCallback);
  });
  const keydown_handler = (e) => e.key === plugin.settings.delete_key && onDeleteKeyDown();
  const keyup_handler = (e) => e.key === plugin.settings.delete_key && onDeleteKeyUp();
  const click_handler = () => new CreateTaskModal(plugin.app, plugin, newTaskTemplate).open();
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refreshButton = $$value;
      $$invalidate(7, refreshButton);
    });
  }
  const statusChange_handler = (task, each_value, tIndex, e) => {
    handleStatusChange(task.uuid, e);
    $$invalidate(5, each_value[tIndex].disabled = true, reportList);
  };
  const click_handler_1 = (task) => {
    new UpdateTaskModal(plugin.app, plugin, { uuid: task.uuid }).open();
  };
  const contextmenu_handler = (task, event) => showActionMenu(task.uuid, event, plugin);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("report" in $$props2)
      $$invalidate(1, report = $$props2.report);
    if ("sanitizedReport" in $$props2)
      $$invalidate(13, sanitizedReport = $$props2.sanitizedReport);
    if ("command" in $$props2)
      $$invalidate(2, command = $$props2.command);
    if ("sanitizedCommand" in $$props2)
      $$invalidate(14, sanitizedCommand = $$props2.sanitizedCommand);
    if ("newTaskTemplate" in $$props2)
      $$invalidate(3, newTaskTemplate = $$props2.newTaskTemplate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*timestamp*/
    32768) {
      $: {
        formatTimestamp(timestamp);
      }
    }
  };
  return [
    plugin,
    report,
    command,
    newTaskTemplate,
    state,
    reportList,
    deleteKeyDown,
    refreshButton,
    formattedAgo,
    getTasks,
    onDeleteKeyDown,
    onDeleteKeyUp,
    handleStatusChange,
    sanitizedReport,
    sanitizedCommand,
    timestamp,
    keydown_handler,
    keyup_handler,
    click_handler,
    button_binding,
    statusChange_handler,
    click_handler_1,
    contextmenu_handler
  ];
}
var TaskList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        plugin: 0,
        report: 1,
        sanitizedReport: 13,
        command: 2,
        sanitizedCommand: 14,
        newTaskTemplate: 3
      },
      add_css6,
      [-1, -1]
    );
  }
};
var TaskList_default = TaskList;

// src/main.ts
var import_tiny_emitter = __toESM(require_tiny_emitter());
var import_crypto2 = require("crypto");
var RightClickMenuAction = class {
  constructor(name, action) {
    this.Action = action;
    this.ActionName = name;
    this.ActionId = (0, import_crypto2.randomUUID)();
  }
};
var DEFAULT_SETTINGS = {
  tw_bin: "task",
  debug_log: false,
  cache_columns: true,
  delete_key: "Alt",
  right_click_context_menu_enabled: false,
  right_click_context_menu_actions: []
};
var LifeCycleHookMRC = class extends import_obsidian8.MarkdownRenderChild {
  constructor(el, component) {
    super(el);
    this.component = component;
  }
  onunload() {
    this.component.$destroy();
  }
};
var TWPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.emitter = void 0;
    this.handler = void 0;
    this.logger = void 0;
  }
  async onload() {
    await this.loadSettings();
    this.emitter = new import_tiny_emitter.TinyEmitter();
    this.handler = new TaskHandler(this);
    this.logger = new TWPluginLogger(this.settings.debug_log);
    this.addCommand({
      id: "create-new-task",
      name: "Create task",
      callback: () => {
        new CreateTaskModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "undo",
      name: "Undo last task action",
      callback: () => {
        var _a;
        (_a = this.handler) == null ? void 0 : _a.undo();
      }
    });
    this.registerMarkdownCodeBlockProcessor("tw", (source, el, ctx) => {
      var _a, _b, _c;
      const input = source.trim().split("\n");
      const report = (_a = input[0]) == null ? void 0 : _a.trim();
      const command = (_b = input[1]) == null ? void 0 : _b.trim();
      const newTaskTemplate = (_c = input[2]) == null ? void 0 : _c.trim();
      const svelteComponent = new TaskList_default({
        target: el,
        props: {
          plugin: this,
          report,
          sanitizedReport: sanitizeSingleArgument(report),
          command,
          sanitizedCommand: command ? sanitize(command) : "",
          newTaskTemplate
        }
      });
      const component = new LifeCycleHookMRC(el, svelteComponent);
      ctx.addChild(component);
    });
    this.registerInterval(window.setInterval(() => {
      var _a;
      return (_a = this.emitter) == null ? void 0 : _a.emit("interval-fetch" /* INTERVAL */);
    }, 1e4));
    this.addSettingTab(new TWSettingTab(this.app, this));
  }
  onunload() {
    var _a, _b;
    (_a = this.emitter) == null ? void 0 : _a.off("interval-fetch" /* INTERVAL */);
    (_b = this.emitter) == null ? void 0 : _b.off("pending-refresh" /* REFRESH */);
    this.emitter = void 0;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var TWSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian8.Setting(containerEl).setName("TaskWarrior path").setDesc("Path of the taskwarrior executable").addText((text2) => text2.setPlaceholder("/usr/bin/task").setValue(this.plugin.settings.tw_bin).onChange(async (value) => {
      this.plugin.settings.tw_bin = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Debug log").setDesc("Enable debug logging. Prints taskwarrior commands to web console.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug_log).onChange(async (value) => {
      this.plugin.settings.debug_log = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Columns cache").setDesc("Cache report columns/labels for faster reloading. Disable if you fiddle with the taskwarrior report columns too much :).").addButton((button) => {
      button.setButtonText("Clear cache").onClick(async () => {
        var _a;
        const cleared = (_a = this.plugin.handler) == null ? void 0 : _a.clearColumnCache();
        if (cleared !== void 0)
          new import_obsidian8.Notice(`Cleared ${cleared} cached reports`);
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.cache_columns).onChange(async (value) => {
      this.plugin.settings.cache_columns = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Deletion hold Key").setDesc("Hold key to enable task deletion").addText((text2) => text2.setPlaceholder("Alt").setValue(this.plugin.settings.delete_key).onChange(async (value) => {
      this.plugin.settings.delete_key = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Enable custom actions context menu").setDesc("Will enable feature of custom actions on context menu on right click.").addToggle((toggle) => toggle.setValue(this.plugin.settings.right_click_context_menu_enabled).onChange(async (value) => {
      this.plugin.settings.right_click_context_menu_enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.right_click_context_menu_enabled) {
      new import_obsidian8.Setting(containerEl).setName("Add Action: ").setDesc("").addButton((button) => {
        button.setButtonText("+").onClick(async () => {
          this.plugin.settings.right_click_context_menu_actions.push(new RightClickMenuAction("", ""));
          this.display();
        });
      });
      for (const [index, action] of this.plugin.settings.right_click_context_menu_actions.entries()) {
        new import_obsidian8.Setting(containerEl).setName("Action: ").setDesc("").addText((text2) => text2.setPlaceholder("Name").setValue(action.ActionName).onChange(async (value) => {
          this.plugin.settings.right_click_context_menu_actions[index].ActionName = value;
          await this.plugin.saveSettings();
        })).addText((text2) => text2.setPlaceholder("Example +today").setValue(action.Action).onChange(async (value) => {
          this.plugin.settings.right_click_context_menu_actions[index].Action = value;
          await this.plugin.saveSettings();
        })).addButton((button) => {
          button.setButtonText("-").onClick(async () => {
            this.plugin.settings.right_click_context_menu_actions = this.plugin.settings.right_click_context_menu_actions.filter((x) => x.ActionId != action.ActionId);
            await this.plugin.saveSettings();
            this.display();
          });
        });
      }
    }
  }
};
